## 编程作业

第一步先重写sys_get_time和sys_task_info。首先使用git cherry-pick将ch2的内容合并到当前分支，解决完冲突后运行，发现qemu启动执行程序后会陷入死循环状态，推测是传入函数的祼指针是虚拟地址，需要翻译成物理地址后才能正确读写数据。根据文档提示，参考sys_write的实现，可以使用现成的translated_byte_buffer。translated_byte_buffer接受一个token（包含根页表的地址）、指向虚地址的指针、长度，返回虚地址对应的物理地址上指定长度的字节数组的可变引用。我们可以使用current_user_token()获取当前应用程序的token。

以sys_get_time为例，先将需要写入指针的数据生成一个临时变量，用from_raw_parts生成该临时变量对应的字节切片。将指针传入translated_byte_buffer得到对应物理地址上字节数组的可变引用。需要注意的是在translated_byte_buffer内部循环里考虑了数据跨页的问题，所以返回的是包含字节数组可变引用的Vec。将临时变量的字节切片全部写入可变引用，这样用户程序就能通过指针读取正确数据了，sys_task_info的思路类似。问题：当应用程序声明初始化变量时，它的页表映射和物理内存的分配是何时发生的？答：在创建应用地址空间时，from_elf函数负责将elf文件里的各个段加入到对应地址空间里，在MemorySet.push里就涉及了页表映射的建立和物理内存的分配。具体来说PageTable.find_pte_create和MemorySet的成员areas里有页表的映射建立，PageTable.find_pte_create和MapArea.map里涉及了页帧分配。

然后实现sys_mmap。sys_mmap用于申请内存，即在地址空间上建设虚拟地址到物理地址的映射，并分配对应的物理页帧。在地址空间上申请内存是以逻辑段为单位申请的，并有一个现成的insert_framed_area将指定地址范围作为逻辑段插入地址空间中（同时完成页表的映射和物理页帧的分配）。先获得当前应用的地址空间，再检查起始地址是否页对齐、内存页属性port是否合法和地址范围中是否已经存在被映射的页，若是结束程序返回-1。每个任务里保存有一个地址空间，为了方便使用修改地址空间，在task/mod.rs新增mmap和munmap接口。将port转换成MapPermission时要注意将U位设置成1，不然U态的代码无法访问。

最后实现sys_munmap。对start的检查同上，再检查地址范围内是否有没被映射过的页，如果有返回-1。MemorySet里的areas变量存放了所有被映射过的逻辑段，我们将地址范围转换成逻辑段在其中查找，找到后用MapArea的unmap方法将其释放。

## 问答作业

1. SV39 页表项的组成及标志位作用如下:

	1. PPN (物理页号, Physical Page Number):
	    
	    - 占用 44 位 (bit 10-53)
	    - 指向下一级页表或最终的物理页面
	2. 标志位 (共 10 位):
	    
	    a. V (Valid, bit 0):
	    
	    - 1 表示该页表项有效
	    - 0 表示无效,会导致页错误
	    
	    b. R (Read, bit 1):
	    
	    - 1 表示允许读取
	    - 0 表示禁止读取
	    
	    c. W (Write, bit 2):
	    
	    - 1 表示允许写入
	    - 0 表示禁止写入
	    
	    d. X (Execute, bit 3):
	    
	    - 1 表示允许执行
	    - 0 表示禁止执行
	    
	    e. U (User, bit 4):
	    
	    - 1 表示用户态可访问
	    - 0 表示仅内核态可访问
	    
	    f. G (Global, bit 5):
	    
	    - 1 表示全局映射,TLB刷新时保留
	    - 0 表示非全局映射
	    
	    g. A (Accessed, bit 6):
	    
	    - 硬件设置,表示该页面已被访问
	    
	    h. D (Dirty, bit 7):
	    
	    - 硬件设置,表示该页面已被写入
	    
	    i. RSW (Reserved for Supervisor Software, bit 8-9):  
	    i. RSW（保留给监督软件，位 8-9）：
	    
	    - 预留给特权软件使用

这些标志位的组合可以实现不同的访问权限控制、内存管理策略等功能,为操作系统提供了灵活的内存管理机制。

2.  缺页
	1. 缺页可能导致的异常：
	    
	    - 加载页错误 (Load Page Fault)
	    - 存储页错误 (Store Page Fault)
	    - 指令页错误 (Instruction Page Fault)
	2. 缺页时相关重要寄存器的值：
	    
	    - `sepc`: 存储发生异常的指令地址
	    - `stval`: 存储导致异常的虚拟地址
	    - `scause`: 存储异常原因（如 12/13/15 分别对应上述三种页错误）
	    - `sstatus`: 保存异常发生时的特权级等信息
	3. Lazy 策略的好处：
	    
	    - 节省内存：只在实际需要时才分配物理内存
	    - 加快进程启动：无需等待所有内存页面加载完成
	    - 提高内存利用率：避免为未使用的内存空间分配资源
	    - 减少不必要的 I/O 操作：只在需要时才从磁盘读取数据
	4. 10G 连续内存页面对应的 SV39 页表大致占用内存：
	    
	    - 每个页表项 8 字节
	    - 一级页表：8 KB
	    - 二级页表：8 MB
	    - 三级页表：4 GB
	    - 总计约 4 GB 量级
	5. 实现 Lazy 策略的思路：
	    
	    - 在 mmap 时只分配虚拟地址空间，不实际分配物理页面
	    - 将对应的页表项标记为无效（V=0）
	    - 记录内存区域的属性（如权限、文件映射信息等）
	    
	    缺页处理：
	    
	    - 检查触发缺页的地址是否在合法的 mmap 区域内
	    - 如果合法，分配物理页面，更新页表项
	    - 如果是文件映射，从文件读取数据到新分配的页面
	    - 最后重新执行触发缺页的指令
	6. swap 策略下，页面失效在页表项 (PTE) 上的表现：
	    
	    - V (Valid) 位设置为 0，表示该页表项无效
	    - PPN 字段可能用于存储页面在磁盘上的位置信息
	    - 可能会设置一个特殊的标志位来表明该页面被换出到磁盘

3. 单页表与多页表
	1. 从用户态进行内核态不用换页表。在切换任务时需要更换，通过更新satp寄存器的值来更换页表。
	2. 将内核页面对应pte的U置为0
	3. 每个应用只用维护一套页表，节省内存，且从用户态切换到内核态时不用更换页表。
	4. 在双页表实现下，在用户态切换内核态和任务切换时都需要切换页表。单页表操作系统只需在任务切换时切换页表即可。
